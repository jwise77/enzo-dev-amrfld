/***********************************************************************
/
/  READ A PARAMETER FILE
/
/  written by: Greg Bryan
/  date:       November, 1994
/  modified1:  Robert Harkness
/  date:       June 25, 2006
/  modified2:  Robert Harkness
/  date:       February 29th, 2008
/  modified3:  Robert Harkness
/  date:       May, 2008
/
/  PURPOSE:
/
/  RETURNS: SUCCESS or FAIL
/
************************************************************************/
 
// This routine reads the parameter file in the argument and sets parameters
//   based on it.
 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <math.h>
#include "ErrorExceptions.h"
#include "macros_and_parameters.h"
#include "typedefs.h"
#include "global_data.h"
#include "Fluxes.h"
#include "GridList.h"
#include "ExternalBoundary.h"
#include "Grid.h"
#include "TopGridData.h"
#include "StarParticleData.h"
#include "hydro_rk/EOS.h" 
 
/* This variable is declared here and only used in Grid_ReadGrid. */
 
/* function prototypes */
 
int ReadListOfFloats(FILE *fptr, int N, float floats[]);
int ReadListOfInts(FILE *fptr, int N, int nums[]);
int CosmologyReadParameters(FILE *fptr, FLOAT *StopTime, FLOAT *InitTime);
int ReadUnits(FILE *fptr);
int InitializeRateData(FLOAT Time);
int InitializeEquilibriumCoolData(FLOAT Time);
int InitializeRadiationFieldData(FLOAT Time);
int GetUnits(float *DensityUnits, float *LengthUnits,
	     float *TemperatureUnits, float *TimeUnits,
	     float *VelocityUnits, FLOAT Time);
 
 
int ReadParameterFile(FILE *fptr, TopGridData &MetaData, float *Initialdt)
{
  /* declarations */
 
  char line[MAX_LINE_LENGTH];
  int dim, ret, int_dummy;
  float TempFloat;
  char *dummy = new char[MAX_LINE_LENGTH];
  dummy[0] = 0;
 
  /* read until out of lines */
 
  while (fgets(line, MAX_LINE_LENGTH, fptr) != NULL) {

    ret = 0;
 
    /* read MetaData parameters */
 
    ret += sscanf(line, "InitialCycleNumber = %"ISYM, &MetaData.CycleNumber);
    ret += sscanf(line, "InitialTime        = %"PSYM, &MetaData.Time);
    ret += sscanf(line, "InitialCPUTime     = %"FSYM, &MetaData.CPUTime);
    ret += sscanf(line, "Initialdt          = %"FSYM, &Initialdt);
 
    ret += sscanf(line, "StopTime    = %"PSYM, &MetaData.StopTime);
    ret += sscanf(line, "StopCycle   = %"ISYM, &MetaData.StopCycle);
    ret += sscanf(line, "StopSteps   = %"ISYM, &MetaData.StopSteps);
    ret += sscanf(line, "StopCPUTime = %"FSYM, &MetaData.StopCPUTime);
    ret += sscanf(line, "ResubmitOn  = %"ISYM, &MetaData.ResubmitOn);
    if (sscanf(line, "ResubmitCommand = %s", dummy) == 1) 
      MetaData.ResubmitCommand = dummy;
 
    ret += sscanf(line, "TimeLastRestartDump = %"PSYM,
		  &MetaData.TimeLastRestartDump);
    ret += sscanf(line, "dtRestartDump       = %"PSYM, &MetaData.dtRestartDump);
    ret += sscanf(line, "TimeLastDataDump    = %"PSYM,
		  &MetaData.TimeLastDataDump);
    ret += sscanf(line, "dtDataDump          = %"PSYM, &MetaData.dtDataDump);
    ret += sscanf(line, "TimeLastHistoryDump = %"PSYM,
		  &MetaData.TimeLastHistoryDump);
    ret += sscanf(line, "dtHistoryDump       = %"PSYM, &MetaData.dtHistoryDump);
 
    ret += sscanf(line, "TracerParticleOn  = %"ISYM, &TracerParticleOn);
    ret += sscanf(line, "ParticleTypeInFile = %"ISYM, &ParticleTypeInFile);
    ret += sscanf(line, "TimeLastTracerParticleDump = %"PSYM,
                  &MetaData.TimeLastTracerParticleDump);
    ret += sscanf(line, "dtTracerParticleDump       = %"PSYM,
                  &MetaData.dtTracerParticleDump);
 
    ret += sscanf(line, "NewMovieLeftEdge  = %"FSYM" %"FSYM" %"FSYM, 
		  MetaData.NewMovieLeftEdge,
		  MetaData.NewMovieLeftEdge+1, 
		  MetaData.NewMovieLeftEdge+2);
    ret += sscanf(line, "NewMovieRightEdge = %"FSYM" %"FSYM" %"FSYM, 
		  MetaData.NewMovieRightEdge, 
		  MetaData.NewMovieRightEdge+1,
		  MetaData.NewMovieRightEdge+2);

    ret += sscanf(line, "CycleLastRestartDump = %"ISYM,
		  &MetaData.CycleLastRestartDump);
    ret += sscanf(line, "CycleSkipRestartDump = %"ISYM,
		  &MetaData.CycleSkipRestartDump);
    ret += sscanf(line, "CycleLastDataDump    = %"ISYM,
		  &MetaData.CycleLastDataDump);
    ret += sscanf(line, "CycleSkipDataDump    = %"ISYM,
		  &MetaData.CycleSkipDataDump);
    ret += sscanf(line, "CycleLastHistoryDump = %"ISYM,
		  &MetaData.CycleLastHistoryDump);
    ret += sscanf(line, "CycleSkipHistoryDump = %"ISYM,
		  &MetaData.CycleSkipHistoryDump);
    ret += sscanf(line, "CycleSkipGlobalDataDump = %"ISYM, //AK
                  &MetaData.CycleSkipGlobalDataDump);
    ret += sscanf(line, "OutputFirstTimeAtLevel = %"ISYM,
		  &MetaData.OutputFirstTimeAtLevel);
    ret += sscanf(line, "StopFirstTimeAtLevel = %"ISYM,
		  &MetaData.StopFirstTimeAtLevel);
 
    /* Subcycle directed output */
    ret += sscanf(line, "SubcycleSkipDataDump = %"ISYM, 
                  &MetaData.SubcycleSkipDataDump);
    ret += sscanf(line, "SubcycleLastDataDump = %"ISYM, 
                  &MetaData.SubcycleLastDataDump);
    ret += sscanf(line, "SubcycleNumber = %"ISYM, 
                  &MetaData.SubcycleNumber);

    ret += sscanf(line,"FileDirectedOutput = %"ISYM,
		  &FileDirectedOutput);

    ret += sscanf(line, "RestartDumpNumber = %"ISYM, &MetaData.RestartDumpNumber);
    ret += sscanf(line, "DataDumpNumber    = %"ISYM, &MetaData.DataDumpNumber);
    ret += sscanf(line, "HistoryDumpNumber = %"ISYM, &MetaData.HistoryDumpNumber);
    ret += sscanf(line, "TracerParticleDumpNumber = %"ISYM, &MetaData.TracerParticleDumpNumber);
 
    if (sscanf(line, "RestartDumpName      = %s", dummy) == 1)
      MetaData.RestartDumpName = dummy;
    if (sscanf(line, "DataDumpName         = %s", dummy) == 1)
      MetaData.DataDumpName = dummy;
    if (sscanf(line, "HistoryDumpName      = %s", dummy) == 1)
      MetaData.HistoryDumpName = dummy;
    if (sscanf(line, "TracerParticleDumpName = %s", dummy) == 1)
      MetaData.TracerParticleDumpName = dummy;
    if (sscanf(line, "RedshiftDumpName     = %s", dummy) == 1)
      MetaData.RedshiftDumpName = dummy;
 
    if (sscanf(line, "RestartDumpDir      = %s", dummy) == 1)
      MetaData.RestartDumpDir = dummy;
    if (sscanf(line, "DataDumpDir         = %s", dummy) == 1)
      MetaData.DataDumpDir = dummy;
    if (sscanf(line, "HistoryDumpDir      = %s", dummy) == 1)
      MetaData.HistoryDumpDir = dummy;
    if (sscanf(line, "TracerParticleDumpDir = %s", dummy) == 1)
      MetaData.TracerParticleDumpDir = dummy;
    if (sscanf(line, "RedshiftDumpDir     = %s", dummy) == 1)
      MetaData.RedshiftDumpDir = dummy;
 
    if (sscanf(line, "LocalDir            = %s", dummy) == 1)
      MetaData.LocalDir = dummy;
    if (sscanf(line, "GlobalDir           = %s", dummy) == 1)
      MetaData.GlobalDir = dummy;
 
    if (sscanf(line, "CubeDump[%"ISYM"] = %s", &dim, dummy) == 2) {
      ret++; CubeDumps[dim] = dummy;
      if (dim >= MAX_CUBE_DUMPS) {
        fprintf(stderr, "CubeDump %"ISYM" > maximum allowed.\n", dim);
        ENZO_FAIL("");
      }
    }

    ret += sscanf(line, "LoadBalancing = %"ISYM, &LoadBalancing);
 
    if (sscanf(line, "TimeActionType[%"ISYM"] = %"ISYM, &dim, &int_dummy) == 2) {
      ret++; TimeActionType[dim] = int_dummy;
      if (dim >= MAX_TIME_ACTIONS-1) {
	fprintf(stderr, "Time action %"ISYM" > maximum allowed.\n", dim);
	ENZO_FAIL("");
      }
    }
    if (sscanf(line, "TimeActionRedshift[%"ISYM"] = ", &dim) == 1)
      ret += sscanf(line, "TimeActionRedshift[%"ISYM"] = %"PSYM, &dim,
		    TimeActionRedshift+dim);
    if (sscanf(line, "TimeActionTime[%"ISYM"] = ", &dim) == 1)
      ret += sscanf(line, "TimeActionTime[%"ISYM"] = %"PSYM, &dim,
		    TimeActionTime+dim);
    if (sscanf(line, "TimeActionParameter[%"ISYM"] = ", &dim) == 1)
      ret += sscanf(line, "TimeActionParameter[%"ISYM"] = %"FSYM, &dim,
		    TimeActionParameter+dim);
 
    ret += sscanf(line, "StaticHierarchy = %"ISYM, &MetaData.StaticHierarchy);
 
    ret += sscanf(line, "TopGridRank       = %"ISYM, &MetaData.TopGridRank);
    ret += sscanf(line, "TopGridDimensions = %"ISYM" %"ISYM" %"ISYM, MetaData.TopGridDims,
		  MetaData.TopGridDims+1, MetaData.TopGridDims+2);
 
    ret += sscanf(line, "TopGridGravityBoundary = %"ISYM,
		  &MetaData.GravityBoundary);
 
    ret += sscanf(line, "ParticleBoundaryType   = %"ISYM,
		  &MetaData.ParticleBoundaryType);
    ret += sscanf(line, "NumberOfParticles      = %"ISYM,
		  &MetaData.NumberOfParticles);
 
    ret += sscanf(line, "CourantSafetyNumber    = %"FSYM,
		  &MetaData.CourantSafetyNumber);
    ret += sscanf(line, "PPMFlatteningParameter = %"ISYM,
		  &MetaData.PPMFlatteningParameter);
    ret += sscanf(line, "PPMDiffusionParameter  = %"ISYM,
		  &MetaData.PPMDiffusionParameter);
    ret += sscanf(line, "PPMSteepeningParameter = %"ISYM,
		  &MetaData.PPMSteepeningParameter);
 
    /* read global Parameters */
 
    ret += sscanf(line, "ProblemType            = %"ISYM, &ProblemType);
    ret += sscanf(line, "HydroMethod            = %"ISYM, &HydroMethod);
    ret += sscanf(line, "huge_number            = %"FSYM, &huge_number);
    ret += sscanf(line, "tiny_number            = %"FSYM, &tiny_number);
    ret += sscanf(line, "Gamma                  = %"FSYM, &Gamma);
    ret += sscanf(line, "PressureFree           = %"ISYM, &PressureFree);
    ret += sscanf(line, "RefineBy               = %"ISYM, &RefineBy);
    ret += sscanf(line, "MaximumRefinementLevel = %"ISYM,
		  &MaximumRefinementLevel);
    ret += sscanf(line, "MaximumGravityRefinementLevel = %"ISYM,
		  &MaximumGravityRefinementLevel);
    ret += sscanf(line, "MaximumParticleRefinementLevel = %"ISYM,
		  &MaximumParticleRefinementLevel);
    ret += sscanf(line, "CellFlaggingMethod     = %"ISYM" %"ISYM" %"ISYM" %"ISYM" %"ISYM" %"ISYM" %"ISYM,
	     CellFlaggingMethod+0, CellFlaggingMethod+1, CellFlaggingMethod+2,
	     CellFlaggingMethod+3, CellFlaggingMethod+4, CellFlaggingMethod+5,
	     CellFlaggingMethod+6);
    ret += sscanf(line, "FluxCorrection         = %"ISYM, &FluxCorrection);
    ret += sscanf(line, "InterpolationMethod    = %"ISYM, &InterpolationMethod);
    ret += sscanf(line, "ConservativeInterpolation = %"ISYM,
		  &ConservativeInterpolation);
    ret += sscanf(line, "MinimumEfficiency      = %"FSYM, &MinimumEfficiency);
    ret += sscanf(line, "MinimumSubgridEdge     = %"ISYM, &MinimumSubgridEdge);
    ret += sscanf(line, "MaximumSubgridSize     = %"ISYM, &MaximumSubgridSize);
    ret += sscanf(line, "NumberOfBufferZones    = %"ISYM, &NumberOfBufferZones);
 
    ret += sscanf(line, "DomainLeftEdge        = %"PSYM" %"PSYM" %"PSYM, DomainLeftEdge,
		  DomainLeftEdge+1, DomainLeftEdge+2);
    ret += sscanf(line, "DomainRightEdge       = %"PSYM" %"PSYM" %"PSYM, DomainRightEdge,
		  DomainRightEdge+1, DomainRightEdge+2);
    ret += sscanf(line, "GridVelocity          = %"FSYM" %"FSYM" %"FSYM, GridVelocity,
		  GridVelocity+1, GridVelocity+2);
    ret += sscanf(line, "RefineRegionAutoAdjust = %"ISYM, &RefineRegionAutoAdjust);
    ret += sscanf(line, "RefineRegionLeftEdge  = %"PSYM" %"PSYM" %"PSYM,
		  RefineRegionLeftEdge, RefineRegionLeftEdge+1,
		  RefineRegionLeftEdge+2);
    ret += sscanf(line, "RefineRegionRightEdge = %"PSYM" %"PSYM" %"PSYM,
		  RefineRegionRightEdge, RefineRegionRightEdge+1,
		  RefineRegionRightEdge+2);
 
    if (sscanf(line, "DataLabel[%"ISYM"] = %s\n", &dim, dummy) == 2)
      DataLabel[dim] = dummy;
    if (sscanf(line, "DataUnits[%"ISYM"] = %s\n", &dim, dummy) == 2)
      DataUnits[dim] = dummy;
 
    ret += sscanf(line, "UniformGravity          = %"ISYM, &UniformGravity);
    ret += sscanf(line, "UniformGravityDirection = %"ISYM,
		  &UniformGravityDirection);
    ret += sscanf(line, "UniformGravityConstant  = %"FSYM,
		  &UniformGravityConstant);
 
    ret += sscanf(line, "PointSourceGravity         = %"ISYM,&PointSourceGravity);
    ret += sscanf(line, "PointSourceGravityPosition = %"PSYM" %"PSYM" %"PSYM,
		  PointSourceGravityPosition, PointSourceGravityPosition+1,
		  PointSourceGravityPosition+2);
    ret += sscanf(line, "PointSourceGravityConstant = %"FSYM,
		  &PointSourceGravityConstant);
    ret += sscanf(line, "PointSourceGravityCoreRadius = %"FSYM,
		  &PointSourceGravityCoreRadius);
 
    ret += sscanf(line, "SelfGravity           = %"ISYM, &SelfGravity);
    ret += sscanf(line, "GravitationalConstant = %"FSYM, &GravitationalConstant);
    ret += sscanf(line, "S2ParticleSize        = %"FSYM, &S2ParticleSize);
    ret += sscanf(line, "GravityResolution     = %"FSYM, &GravityResolution);
    ret += sscanf(line, "ComputePotential      = %"ISYM, &ComputePotential);
    ret += sscanf(line, "PotentialIterations   = %"ISYM, &PotentialIterations);
    ret += sscanf(line, "WritePotential        = %"ISYM, &WritePotential);
    ret += sscanf(line, "BaryonSelfGravityApproximation = %"ISYM,
		  &BaryonSelfGravityApproximation);
 
    ret += sscanf(line, "GreensFunctionMaxNumber   = %"ISYM,
		  &GreensFunctionMaxNumber);
    ret += sscanf(line, "GreensFunctionMaxSize     = %"ISYM,
		  &GreensFunctionMaxSize);
 
    ret += sscanf(line, "DualEnergyFormalism     = %"ISYM, &DualEnergyFormalism);
    ret += sscanf(line, "DualEnergyFormalismEta1 = %"FSYM,
		  &DualEnergyFormalismEta1);
    ret += sscanf(line, "DualEnergyFormalismEta2 = %"FSYM,
		  &DualEnergyFormalismEta2);
    ret += sscanf(line, "ParticleCourantSafetyNumber = %"FSYM,
		  &ParticleCourantSafetyNumber);
    ret += sscanf(line, "RandomForcing = %"ISYM, &RandomForcing); //AK
    ret += sscanf(line, "RandomForcingEdot = %"FSYM, &RandomForcingEdot); //AK
    ret += sscanf(line, "RandomForcingMachNumber = %"FSYM, //AK
                  &RandomForcingMachNumber);
    ret += sscanf(line, "RadiativeCooling = %"ISYM, &RadiativeCooling);
    ret += sscanf(line, "MultiSpecies = %"ISYM, &MultiSpecies);
    ret += sscanf(line, "MetalCooling = %d", &MetalCooling);
    if (sscanf(line, "MetalCoolingTable = %s", dummy) == 1) 
      MetalCoolingTable = dummy;
    ret += sscanf(line, "RadiationFieldType = %"ISYM, &RadiationFieldType);
    ret += sscanf(line, "AdjustUVBackground = %"ISYM, &AdjustUVBackground);
    ret += sscanf(line, "SetUVBAmplitude = %"FSYM, &SetUVBAmplitude);
    ret += sscanf(line, "SetHeIIHeatingScale = %"FSYM, &SetHeIIHeatingScale);

    ret += sscanf(line, "RadiationFieldLevelRecompute = %"ISYM,
		  &RadiationFieldLevelRecompute);
    ret += sscanf(line, "RadiationSpectrumNormalization = %"FSYM,
		  &CoolData.f3);
    ret += sscanf(line, "RadiationSpectrumSlope = %"FSYM, &CoolData.alpha0);

    if (sscanf(line, "CoolDataParameterFile = %s", dummy) == 1)
      CoolData.ParameterFilename = dummy;

    ret += sscanf(line, "OutputCoolingTime = %"ISYM, &OutputCoolingTime);
    ret += sscanf(line, "OutputTemperature = %"ISYM, &OutputTemperature);

    ret += sscanf(line, "ZEUSQuadraticArtificialViscosity = %"FSYM,
		  &ZEUSQuadraticArtificialViscosity);
    ret += sscanf(line, "ZEUSLinearArtificialViscosity = %"FSYM,
		  &ZEUSLinearArtificialViscosity);
 
    ret += sscanf(line, "UseMinimumPressureSupport = %"ISYM,
		  &UseMinimumPressureSupport);
    ret += sscanf(line, "MinimumPressureSupportParameter = %"FSYM,
		  &MinimumPressureSupportParameter);
    ret += sscanf(line, "RefineByJeansLengthSafetyFactor = %"FSYM,
		  &RefineByJeansLengthSafetyFactor);
    ret += sscanf(line, "MustRefineParticlesRefineToLevel = %"ISYM,
                  &MustRefineParticlesRefineToLevel);
    ret += sscanf(line, "ParticleTypeInFile = %"ISYM,
                  &ParticleTypeInFile);

 
    if (sscanf(line, "StaticRefineRegionLevel[%"ISYM"] = %"ISYM,&dim,&int_dummy) == 2){
      if (dim > MAX_STATIC_REGIONS-1) {
        fprintf(stderr, "StaticRegion number %"ISYM" > MAX allowed\n", dim);
        ENZO_FAIL("");
      }
      ret++;
      StaticRefineRegionLevel[dim] = int_dummy;
    }
    if (sscanf(line, "StaticRefineRegionLeftEdge[%"ISYM"] = ", &dim) == 1)
      ret += sscanf(line,
		    "StaticRefineRegionLeftEdge[%"ISYM"] = %"PSYM" %"PSYM" %"PSYM,
		    &dim, StaticRefineRegionLeftEdge[dim],
		    StaticRefineRegionLeftEdge[dim]+1,
		    StaticRefineRegionLeftEdge[dim]+2);
    if (sscanf(line, "StaticRefineRegionRightEdge[%"ISYM"] = ", &dim) == 1)
      ret += sscanf(line,
		    "StaticRefineRegionRightEdge[%"ISYM"] = %"PSYM" %"PSYM" %"PSYM,
		    &dim, StaticRefineRegionRightEdge[dim],
		    StaticRefineRegionRightEdge[dim]+1,
		    StaticRefineRegionRightEdge[dim]+2);
 
    ret += sscanf(line, "ParallelRootGridIO = %"ISYM, &ParallelRootGridIO);
 
    ret += sscanf(line, "ParallelParticleIO = %"ISYM, &ParallelParticleIO);
 
    ret += sscanf(line, "Unigrid = %"ISYM, &Unigrid);
 
    ret += sscanf(line, "PartitionNestedGrids = %"ISYM, &PartitionNestedGrids);
 
    ret += sscanf(line, "ExtractFieldsOnly = %"ISYM, &ExtractFieldsOnly);
 
    ret += sscanf(line, "CubeDumpEnabled = %"ISYM, &CubeDumpEnabled);
 
    ret += sscanf(line, "Debug1 = %"ISYM, &debug1);

    ret += sscanf(line, "Debug2 = %"ISYM, &debug2);

    ret += sscanf(line, "MemoryLimit = %"ISYM, &MemoryLimit);

#ifdef STAGE_INPUT
    ret += sscanf(line, "StageInput = %"ISYM, &StageInput);
#endif

#ifdef OOC_BOUNDARY

    ret += sscanf(line, "ExternalBoundaryIO = %"ISYM, &ExternalBoundaryIO);

    ret += sscanf(line, "ExternalBoundaryTypeIO = %"ISYM, &ExternalBoundaryTypeIO);

    ret += sscanf(line, "ExternalBoundaryValueIO = %"ISYM, &ExternalBoundaryValueIO);

    ret += sscanf(line, "SimpleConstantBoundary = %"ISYM, &SimpleConstantBoundary);

#endif
 
    ret += sscanf(line, "MinimumOverDensityForRefinement  = "
		  " %"FSYM" %"FSYM" %"FSYM" %"FSYM" %"FSYM" %"FSYM" %"FSYM,
		  MinimumOverDensityForRefinement+0, 
		  MinimumOverDensityForRefinement+1,
		  MinimumOverDensityForRefinement+2, 
		  MinimumOverDensityForRefinement+3,
		  MinimumOverDensityForRefinement+4, 
		  MinimumOverDensityForRefinement+5,
		  MinimumOverDensityForRefinement+6);
    ret += sscanf(line, "MinimumMassForRefinement  = "
		  " %"FSYM" %"FSYM" %"FSYM" %"FSYM" %"FSYM" %"FSYM" %"FSYM,
		  MinimumMassForRefinement+0, 
		  MinimumMassForRefinement+1,
		  MinimumMassForRefinement+2, 
		  MinimumMassForRefinement+3,
		  MinimumMassForRefinement+4, 
		  MinimumMassForRefinement+5,
		  MinimumMassForRefinement+6);
    ret += sscanf(line, "MinimumMassForRefinementLevelExponent = "
		  " %"FSYM" %"FSYM" %"FSYM" %"FSYM" %"FSYM" %"FSYM" %"FSYM,
		  MinimumMassForRefinementLevelExponent+0,
		  MinimumMassForRefinementLevelExponent+1,
		  MinimumMassForRefinementLevelExponent+2,
		  MinimumMassForRefinementLevelExponent+3,
		  MinimumMassForRefinementLevelExponent+4,
		  MinimumMassForRefinementLevelExponent+5,
		  MinimumMassForRefinementLevelExponent+6);
    ret += sscanf(line, "MinimumSlopeForRefinement = %"FSYM,
		  &MinimumSlopeForRefinement);
    ret += sscanf(line, "MinimumPressureJumpForRefinement = %"FSYM,
		  &MinimumPressureJumpForRefinement);
    ret += sscanf(line, "MinimumShearForRefinement = %"FSYM,
		  &MinimumShearForRefinement);
    ret += sscanf(line, "MinimumEnergyRatioForRefinement = %"FSYM,
		  &MinimumEnergyRatioForRefinement);
    ret += sscanf(line, "ComovingCoordinates = %"ISYM,&ComovingCoordinates);
    ret += sscanf(line, "StarParticleCreation = %"ISYM, &StarParticleCreation);
    ret += sscanf(line, "StarParticleFeedback = %"ISYM, &StarParticleFeedback);
    ret += sscanf(line, "NumberOfParticleAttributes = %"ISYM,
		  &NumberOfParticleAttributes);
    ret += sscanf(line, "AddParticleAttributes = %"ISYM, &AddParticleAttributes);

    /* read data which defines the boundary conditions */
 
    ret += sscanf(line, "LeftFaceBoundaryCondition  = %"ISYM" %"ISYM" %"ISYM,
		  MetaData.LeftFaceBoundaryCondition,
		  MetaData.LeftFaceBoundaryCondition+1,
		  MetaData.LeftFaceBoundaryCondition+2);
    ret += sscanf(line, "RightFaceBoundaryCondition = %"ISYM" %"ISYM" %"ISYM,
		  MetaData.RightFaceBoundaryCondition,
		  MetaData.RightFaceBoundaryCondition+1,
		  MetaData.RightFaceBoundaryCondition+2);
    if (sscanf(line, "BoundaryConditionName         = %s", dummy) == 1)
      MetaData.BoundaryConditionName = dummy;
 
    /* Check version number. */
 
    if (sscanf(line, "VersionNumber = %"FSYM, &TempFloat) == 1) {
      ret++;
      if (fabs(TempFloat - VERSION) >= 1.0e-3)
	fprintf(stderr, "Warning: Incorrect version number.\n");
    }
 
    /* Read star particle parameters. */
 
    ret += sscanf(line, "StarMakerOverDensityThreshold = %"FSYM,
		  &StarMakerOverDensityThreshold);
    ret += sscanf(line, "StarMakerMassEfficiency = %"FSYM,
		  &StarMakerMassEfficiency);
    ret += sscanf(line, "StarMakerMinimumMass = %"FSYM, &StarMakerMinimumMass);
    ret += sscanf(line, "StarMakerMinimumDynamicalTime = %"FSYM,
                  &StarMakerMinimumDynamicalTime);
    ret += sscanf(line, "StarMassEjectionFraction = %"FSYM,
		  &StarMassEjectionFraction);
    ret += sscanf(line, "StarMetalYield = %"FSYM, &StarMetalYield);
    ret += sscanf(line, "StarEnergyToThermalFeedback = %"FSYM,
		  &StarEnergyToThermalFeedback);
    ret += sscanf(line, "StarEnergyToStellarUV = %"FSYM, &StarEnergyToStellarUV);
    ret += sscanf(line, "StarEnergyToQuasarUV = %"FSYM, &StarEnergyToQuasarUV);
 

    ret += sscanf(line, "StarClusterUseMetalField = %"ISYM, 
		  &StarClusterUseMetalField);
    ret += sscanf(line, "StarClusterMinDynamicalTime = %"FSYM, 
		  &StarClusterMinDynamicalTime);
    ret += sscanf(line, "StarClusterIonizingLuminosity = %lf", 
		  &StarClusterIonizingLuminosity);
    ret += sscanf(line, "StarClusterSNEnergy = %lf", &StarClusterSNEnergy);
    ret += sscanf(line, "StarClusterSNRadius = %"FSYM, &StarClusterSNRadius);
    ret += sscanf(line, "StarClusterFormEfficiency = %"FSYM, 
		  &StarClusterFormEfficiency);
    ret += sscanf(line, "StarClusterMinimumMass = %"FSYM, 
		  &StarClusterMinimumMass);
    ret += sscanf(line, "StarClusterCombineRadius = %"FSYM,
		  &StarClusterCombineRadius);
    ret += sscanf(line, "StarClusterRegionLeftEdge = %"FSYM" %"FSYM" %"FSYM,
		  StarClusterRegionLeftEdge, StarClusterRegionLeftEdge+1, 
		  StarClusterRegionLeftEdge+2);
    ret += sscanf(line, "StarClusterRegionRightEdge = %"FSYM" %"FSYM" %"FSYM,
		  StarClusterRegionRightEdge, StarClusterRegionRightEdge+1, 
		  StarClusterRegionRightEdge+2);

    ret += sscanf(line, "PopIIIStarMass = %"FSYM, &PopIIIStarMass);
    ret += sscanf(line, "PopIIIBlackHoles = %"ISYM, &PopIIIBlackHoles);
    ret += sscanf(line, "PopIIIBHLuminosityEfficiency = %"FSYM, 
		  &PopIIIBHLuminosityEfficiency);
    ret += sscanf(line, "PopIIIOverDensityThreshold = %"FSYM,
		  &PopIIIOverDensityThreshold);
    ret += sscanf(line, "PopIIIH2CriticalFraction = %"FSYM,
		  &PopIIIH2CriticalFraction);
    ret += sscanf(line, "PopIIIMetalCriticalFraction = %"FSYM,
		  &PopIIIMetalCriticalFraction);
    ret += sscanf(line, "PopIIISupernovaRadius = %"FSYM, &PopIIISupernovaRadius);
    ret += sscanf(line, "PopIIISupernovaUseColour = %"ISYM, 
		  &PopIIISupernovaUseColour);

    /* Read Movie Dump parameters */

    ret += sscanf(line, "MovieSkipTimestep = %d", &MovieSkipTimestep);
    ret += sscanf(line, "Movie3DVolumes = %d", &Movie3DVolumes);
    ret += sscanf(line, "MovieVertexCentered = %d", &MovieVertexCentered);
    ret += sscanf(line, "NewMovieParticleOn = %d", &NewMovieParticleOn);
    ret += sscanf(line, "MovieDataField = %d %d %d %d %d %d",
		  MovieDataField+0, MovieDataField+1, MovieDataField+2,
		  MovieDataField+3, MovieDataField+4, MovieDataField+5);
    ret += sscanf(line, "NewMovieDumpNumber = %d", &NewMovieDumpNumber);
    if (sscanf(line, "NewMovieName = %s", dummy) == 1)
      NewMovieName = dummy;
    ret += sscanf(line, "MovieTimestepCounter = %d", &MetaData.TimestepCounter);

    ret += sscanf(line, "MultiMetals = %"ISYM, &MultiMetals);

    ret += sscanf(line, "RadiativeTransfer = %"ISYM, &RadiativeTransfer);
    ret += sscanf(line, "RadiationXRaySecondaryIon = %"ISYM, 
		  &RadiationXRaySecondaryIon);

#ifdef STAGE_INPUT
    sscanf(line, "LocalPath = %s\n", LocalPath);
    sscanf(line, "GlobalPath = %s\n", GlobalPath);
#endif

    /* This Block for Stanford Hydro */

    ret += sscanf(line, "UseHydro               = %d", &UseHydro);

    /* Sink particles (for present day star formation) & winds */
    ret += sscanf(line, "SinkMergeDistance = %lf", &SinkMergeDistance);
    ret += sscanf(line, "SinkMergeMass        = %f", &SinkMergeMass);
    ret += sscanf(line, "StellarWindFeedback  = %d", &StellarWindFeedback);
    ret += sscanf(line, "StellarWindTurnOnMass = %f", &StellarWindTurnOnMass);

    //    ret += sscanf(line, "VelAnyl = %d", &VelAnyl);


    /* Read MHD Paramters */
    ret += sscanf(line, "UseDivergenceCleaning = %d", &UseDivergenceCleaning);
    ret += sscanf(line, "DivergenceCleaningThreshold = %f", &DivergenceCleaningThreshold);
    ret += sscanf(line, "PoissonApproximationThreshold = %f", &PoissonApproximationThreshold);
    ret += sscanf(line, "AngularVelocity = %f", &AngularVelocity);
    ret += sscanf(line, "VelocityGradient = %f", &VelocityGradient);
    ret += sscanf(line, "UseDrivingField = %d", &UseDrivingField);
    ret += sscanf(line, "DrivingEfficiency = %f", &DrivingEfficiency);

    ret += sscanf(line, "StringKick = %d", &StringKick);
    ret += sscanf(line, "UsePhysicalUnit = %d", &UsePhysicalUnit);
    ret += sscanf(line, "Theta_Limiter = %f", &Theta_Limiter);
    ret += sscanf(line, "RKOrder = %d", &RKOrder);
    ret += sscanf(line, "UseFloor = %d", &UseFloor);
    ret += sscanf(line, "UseViscosity = %d", &UseViscosity);
    ret += sscanf(line, "UseAmbipolarDiffusion = %d", &UseAmbipolarDiffusion);
    ret += sscanf(line, "UseResistivity = %d", &UseResistivity);
    ret += sscanf(line, "SmallRho = %g", &SmallRho);
    ret += sscanf(line, "SmallP = %g", &SmallP);
    ret += sscanf(line, "SmallT = %g", &SmallT);
    ret += sscanf(line, "Coordinate = %d", &Coordinate);
    ret += sscanf(line, "RiemannSolver = %d", &RiemannSolver);
    ret += sscanf(line, "ReconstructionMethod = %d", &ReconstructionMethod);
    ret += sscanf(line, "EOSType = %d", &EOSType);
    ret += sscanf(line, "EOSSoundSpeed = %f", &EOSSoundSpeed);
    ret += sscanf(line, "EOSCriticalDensity = %f", &EOSCriticalDensity);
    ret += sscanf(line, "EOSGamma = %f", &EOSGamma);
    ret += sscanf(line, "UseConstantAcceleration = %d", &UseConstantAcceleration);
    ret += sscanf(line, "ConstantAcceleration = %g %g %g", &ConstantAcceleration[0],
		  &ConstantAcceleration[1], &ConstantAcceleration[2]);
    ret += sscanf(line, "Mu = %g", &Mu);
    ret += sscanf(line, "CoolingCutOffDensity1 = %g", &CoolingCutOffDensity1);
    ret += sscanf(line, "CoolingCutOffDensity2 = %g", &CoolingCutOffDensity2);
    ret += sscanf(line, "CoolingCutOffTemperature = %g", &CoolingCutOffTemperature);
    ret += sscanf(line, "CoolingPowerCutOffDensity1 = %g", &CoolingPowerCutOffDensity1);
    ret += sscanf(line, "CoolingPowerCutOffDensity2 = %g", &CoolingPowerCutOffDensity2);
    ret += sscanf(line, "UseH2OnDust           = %d", &UseH2OnDust);
    ret += sscanf(line, "PhotoelectricHeating  = %lf", &PhotoelectricHeating);

#ifdef ECUDA
    ret += sscanf(line, "UseCUDA = %d",&UseCUDA);
#endif

 
    /* If the dummy char space was used, then make another. */
 
    if (*dummy != 0) {
      dummy = new char[MAX_LINE_LENGTH];
      ret++;
    }
 
    /* check to see if the line belongs to one of the test problems */
 
    if (strstr(line, "ShockTube")           ) ret++;
    if (strstr(line, "WavePool" )           ) ret++;
    if (strstr(line, "ShockPool")           ) ret++;
    if (strstr(line, "DoubleMach")          ) ret++;
    if (strstr(line, "Implosion")           ) ret++;
    if (strstr(line, "SedovBlast")          ) ret++;
    if (strstr(line, "Units")               ) ret++;
    if (strstr(line, "RotatingCylinder")    ) ret++;
    if (strstr(line, "TestOrbit")    ) ret++;
    if (strstr(line, "TestProblem")    ) ret++;
    if (strstr(line, "KelvinHelmholtz")     ) ret++;
    if (strstr(line, "KH")                  ) ret++;
    if (strstr(line, "Noh")                 ) ret++;
    if (strstr(line, "ZeldovichPancake")    ) ret++;
    if (strstr(line, "PressurelessCollapse")) ret++;
    if (strstr(line, "AdiabaticExpansion" ) ) ret++;
    if (strstr(line, "CosmologySimulation") ) ret++;
    if (strstr(line, "TestGravity"        ) ) ret++;
    if (strstr(line, "SphericalInfall"    ) ) ret++;
    if (strstr(line, "TestGravitySphere"  ) ) ret++;
    if (strstr(line, "CollapseTest"       ) ) ret++;
    if (strstr(line, "Cosmology"          ) ) ret++;
    if (strstr(line, "SupernovaRestart"   ) ) ret++;
    if (strstr(line, "TracerParticleCreation")) ret++;
    if (strstr(line, "TurbulenceSimulation")) ret++;
    if (strstr(line, "ProtostellarCollapse")) ret++;
    if (strstr(line, "CoolingTest")) ret++;
#ifdef TRANSFER
    if (strstr(line, "Radiative")           ) ret++;
    if (strstr(line, "PhotonTest")          ) ret++;
#endif
 
    /* if the line is suspicious, issue a warning */
 
    if (ret == 0 && strstr(line, "=") != NULL && line[0] != '#')
      if (MyProcessorNumber == ROOT_PROCESSOR)
	fprintf(stderr, "warning: the following parameter line was not interpreted:\n%s", line);
 
  }
 
  /* clean up */
 
  delete [] dummy;
  rewind(fptr);
 
  /* If we have turned on Comoving coordinates, read cosmology parameters. */
 
  if (ComovingCoordinates) {
    if (CosmologyReadParameters(fptr, &MetaData.StopTime, &MetaData.Time)
	== FAIL) {
      fprintf(stderr, "Error in ReadCosmologyParameters.\n");;
      ENZO_FAIL("");
    }
    rewind(fptr);
  }
  else {
    if (ReadUnits(fptr) == FAIL){
      ENZO_FAIL("Error in ReadUnits. ");
    }
    rewind(fptr);
  }

  float DensityUnits = 1.0, LengthUnits = 1.0, TemperatureUnits = 1.0, 
    TimeUnits = 1.0, VelocityUnits = 1.0, PressureUnits = 1.0;
  double MassUnits = 1.0;
  if (UsePhysicalUnit) {
    GetUnits(&DensityUnits, &LengthUnits, &TemperatureUnits, &TimeUnits, &VelocityUnits, 
	     MetaData.Time);
    PressureUnits = DensityUnits*pow(VelocityUnits,2);
    MassUnits = DensityUnits*pow(LengthUnits,3);
  }

  /* Change input physical parameters into code units */

  double mh = 1.6726e-24;
  double uheat = pow(VelocityUnits,2)*2.0*mh/TimeUnits;
  PhotoelectricHeating /= uheat;
  StarMakerOverDensityThreshold /= DensityUnits;
  //  StarEnergyFeedbackRate = StarEnergyFeedbackRate/pow(LengthUnits,2)*pow(TimeUnits,3);

  SinkMergeDistance /= LengthUnits;
  SmallRho /= DensityUnits;
  SmallP /= PressureUnits;
  SmallT /= TemperatureUnits;
  float h, cs, dpdrho, dpde;
  EOS(SmallP, SmallRho, SmallEint, h, cs, dpdrho, dpde, EOSType, 1);
  printf("smallrho=%g, smallp=%g, smalleint=%g, PressureUnits=%g\n",
         SmallRho, SmallP, SmallEint, PressureUnits);
  for (int i = 0; i < MAX_FLAGGING_METHODS; i++) {
    if (MinimumMassForRefinement[i] != FLOAT_UNDEFINED) {
      MinimumMassForRefinement[i] /= MassUnits;
    }
  }

  if (!ComovingCoordinates && UsePhysicalUnit) {
    for (int i = 0; i < MAX_FLAGGING_METHODS; i++) {
      if (MinimumOverDensityForRefinement[i] != FLOAT_UNDEFINED) {
	MinimumOverDensityForRefinement[i] /= DensityUnits;
      }
    }
  }

  /* If set, initialize the RadiativeCooling and RateEquations data. */

  if (MultiSpecies > 0)
    if (InitializeRateData(MetaData.Time) == FAIL) {
      ENZO_FAIL("Error in InitializeRateData.");
    }
 
  if (MultiSpecies             == 0 && 
      RadiativeCooling          > 0) {
    if (InitializeEquilibriumCoolData(MetaData.Time) == FAIL) {
      ENZO_FAIL("Error in InitializeEquilibriumCoolData.");
    }
  }
 
  /* If using the internal radiation field, initialize it. */
 
  if (RadiationFieldType >= 10 && RadiationFieldType <= 11)
    if (InitializeRadiationFieldData(MetaData.Time) == FAIL) {
	ENZO_FAIL("Error in InitializeRadiationFieldData.");
      }
 
  /* Turn off DualEnergyFormalism for zeus hydro (and a few other things). */
 
  if (HydroMethod == Zeus_Hydro) {
    ConservativeInterpolation = FALSE;
    DualEnergyFormalism       = FALSE;
    //    FluxCorrection            = FALSE;
  }
 
  if (DualEnergyFormalism) {
    NEQ_HYDRO = 6;
    NEQ_MHD   = 10;
    ieint = 5;
    iBx = 6;
    iBy = 7;
    iBz = 8;
    iPhi = 9;
    iEint = 5;
  }

  /* Set the number of particle attributes, if left unset. */
 
  if (NumberOfParticleAttributes == INT_UNDEFINED)
    if (StarParticleCreation || StarParticleFeedback)
      NumberOfParticleAttributes = 3;
    else
      NumberOfParticleAttributes = 0;
 
#ifdef UNUSED
  if (MaximumGravityRefinementLevel == INT_UNDEFINED)
    MaximumGravityRefinementLevel = (RadiativeCooling && SelfGravity
				     && HydroMethod == Zeus_Hydro) ?
       max(MaximumRefinementLevel-2, 5) : MaximumRefinementLevel;
#else
  if (MaximumGravityRefinementLevel == INT_UNDEFINED)
    MaximumGravityRefinementLevel = MaximumRefinementLevel;
#endif
 
  MaximumGravityRefinementLevel =
    min(MaximumGravityRefinementLevel, MaximumRefinementLevel);
 
  /* If MultiSpecies < 2, we can't simulate Pop III star formation */

  if (MultiSpecies < 2 && STARMAKE_METHOD(POP3_STAR)) {
    if (MyProcessorNumber == ROOT_PROCESSOR)
      fprintf(stderr, "Cannot form Pop III stars without H2 cooling!\n"
	      "Turning Pop III star formation OFF.\n");
    StarParticleCreation -= 1 << POP3_STAR;
  }

  /* Use the value in MaximumParticleRefinementLevel to set the smoothing
     radius for the particles, to be used to Grid_DepositPositions. */
 
  if (MaximumParticleRefinementLevel >= 0)
    DepositPositionsParticleSmoothRadius =
      (DomainRightEdge[0] - DomainLeftEdge[0])/
      (float(MetaData.TopGridDims[0])*
       POW(float(RefineBy), float(MaximumParticleRefinementLevel)));
  else
    DepositPositionsParticleSmoothRadius = 0;
 
//  PPMDiffusion causes an out-of-bounds condition as currently written
//  The following is an over-ride to force PPMDiffusion OFF. This has
//  been fixed in this latest version (AK).

  if (MetaData.PPMDiffusionParameter != 0 && ProblemType != 60 // Turbulence
                                          && ProblemType != 4  // Double Mach Reflection test
                                          && ProblemType != 6  // Implosion test
                                          && ProblemType != 7  // SedovBlast test
                                          && ProblemType != 8  // KH test
                                          && ProblemType != 9  // Noh test
                                          ) {
    if (MyProcessorNumber == ROOT_PROCESSOR)
      printf("WARNING! Setting MetaData.PPMDiffusionParameter = 0\n");
    MetaData.PPMDiffusionParameter = 0;
  }
 
  if (PartitionNestedGrids == 1) {
    if (MyProcessorNumber == ROOT_PROCESSOR)
      printf("WARNING! PartitionNestedGrids = 1 forces Parallel IO = 1\n");
    ParallelRootGridIO = 1;
    ParallelParticleIO = 1;
  }

  /* If refining by must-refine particles, particle mass refinement
     must be turned on. */

  int method;
  bool MustRefineParticles = false;
  for (method = 0; method < MAX_FLAGGING_METHODS; method++)
    if (CellFlaggingMethod[method] == 8) {
      MustRefineParticles = true;
      break;
    }
  if (MustRefineParticles) {
    method = 0;
    while (CellFlaggingMethod[method] != INT_UNDEFINED)
      method++;
    CellFlaggingMethod[method] = 4;
  }

  if (TracerParticleOn) {
    ParticleTypeInFile = TRUE;
  }
 
  if (WritePotential && ComovingCoordinates && SelfGravity) {
    CopyGravPotential = TRUE;
  }

  if (MyProcessorNumber == ROOT_PROCESSOR) {
 
    if ( MetaData.GlobalDir != NULL ) {
      fprintf(stderr, "Output to Global Dir %s\n", MetaData.GlobalDir);
    }
 
    if ( MetaData.LocalDir != NULL ) {
      fprintf(stderr, "Output to Local Dir %s\n", MetaData.LocalDir);
    }

  }
 
  if ( (MetaData.GlobalDir != NULL) && (MetaData.LocalDir != NULL) ) {
    ENZO_FAIL("Cannot select GlobalDir AND LocalDir!\n");
  }
 
  char *cwd_buffer = new char[MAX_LINE_LENGTH];
  size_t cwd_buffer_len = MAX_LINE_LENGTH;
 
  if ( (MetaData.GlobalDir == NULL) && (MetaData.LocalDir == NULL) ) {
    if(getcwd(cwd_buffer, cwd_buffer_len) == NULL) {
      fprintf(stderr, "GETCWD call FAILED\n");
    }
    if (MyProcessorNumber == ROOT_PROCESSOR)
      fprintf(stderr,"CWD %s\n", cwd_buffer);
    MetaData.GlobalDir = cwd_buffer;
    if (MyProcessorNumber == ROOT_PROCESSOR)
      fprintf(stderr,"Global Dir set to %s\n", cwd_buffer);
  }
 
  return SUCCESS;
}
